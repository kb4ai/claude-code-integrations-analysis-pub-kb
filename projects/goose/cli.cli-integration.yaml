# CLI Integration Analysis: Goose
# Spec: specs/cli-integration.spec.yaml

project: "goose"
cli_integration_detected: true

summary: |
  Goose spawns `claude` CLI as a persistent subprocess using bidirectional NDJSON (stream-json)
  protocol. Unlike most integrations that spawn per-request, Goose keeps a long-running Claude process
  and communicates via stdin/stdout JSON messages. Supports model selection, permission mode mapping,
  and custom system prompts.

invocations:

  - id: claude-code-provider-spawn
    description: "Spawns Claude Code CLI as persistent subprocess with stream-json I/O"

    reference:
      repository: "https://github.com/block/goose"
      commit: "b18120bec310365d96cafcc34ea63d8534e3ee57"
      path: "crates/goose/src/providers/claude_code.rs"
      lines: [278, 298]
      function: "execute_command"
      class: "ClaudeCodeProvider"
      language: "rust"

    command_pattern: "claude --input-format stream-json --output-format stream-json --verbose --system-prompt {prompt} [--model {model}] [--dangerously-skip-permissions]"

    flags_used:
      - flag: "--input-format"
        value_type: "enum"
        value_options: ["stream-json"]
        purpose: "Accept NDJSON messages on stdin for bidirectional communication"
        checklist_ref: "cli-flags.checklist.yaml#input-format"

      - flag: "--output-format"
        value_type: "enum"
        value_options: ["stream-json"]
        purpose: "Emit NDJSON messages on stdout for real-time streaming"
        checklist_ref: "cli-flags.checklist.yaml#output-format"

      - flag: "--verbose"
        value_type: "flag"
        purpose: "Required for stream-json output format"
        checklist_ref: "cli-flags.checklist.yaml#verbose"

      - flag: "--system-prompt"
        value_type: "string"
        purpose: "Pass custom system prompt for agent behavior (filtered to remove extensions)"
        checklist_ref: "cli-flags.checklist.yaml#system-prompt"

      - flag: "--model"
        value_type: "string"
        purpose: "Model selection - only passed for values in CLAUDE_CODE_KNOWN_MODELS ('sonnet', 'opus')"
        checklist_ref: "cli-flags.checklist.yaml#model"

      - flag: "--dangerously-skip-permissions"
        value_type: "flag"
        purpose: "Auto-approve all operations when GooseMode::Auto"
        checklist_ref: "cli-flags.checklist.yaml#dangerously-skip-permissions"

      - flag: "--permission-mode"
        value_type: "string"
        value_options: ["acceptEdits"]
        purpose: "Accept edits mode when GooseMode::SmartApprove"
        checklist_ref: "cli-flags.checklist.yaml#permission-mode"

    snippet: |
      // In execute_command(), lines 278-298: lazy spawn via OnceCell
      let mut cmd = Command::new(&self.command);
      // NO -p flag — persistent mode
      configure_command_no_window(&mut cmd);
      cmd.arg("--input-format")
          .arg("stream-json")
          .arg("--output-format")
          .arg("stream-json")
          .arg("--verbose")
          .arg("--system-prompt")
          .arg(&filtered_system);

      // Only pass model parameter if it's in the known models list
      if CLAUDE_CODE_KNOWN_MODELS.contains(&self.model.model_name.as_str()) {
          cmd.arg("--model").arg(&self.model.model_name);
      }

      // Add permission mode based on GOOSE_MODE setting
      Self::apply_permission_flags(&mut cmd)?;

      // apply_permission_flags (lines 122-147) maps GooseMode enum:
      // GooseMode::Auto => --dangerously-skip-permissions
      // GooseMode::SmartApprove => --permission-mode acceptEdits
      // GooseMode::Approve => error (not supported)
      // GooseMode::Chat => no flags

    environment_variables:
      - name: "CLAUDE_CODE_COMMAND"
        purpose: "Override Claude Code binary path (default: 'claude') - resolved via Config::get_claude_code_command()"
      - name: "GOOSE_MODE"
        purpose: "Maps to CLI permission flags via GooseMode enum: Auto→--dangerously-skip-permissions, SmartApprove→--permission-mode acceptEdits"

    notes: |
      Unique persistent process pattern: Unlike claude-code-mcp which spawns per-request,
      Goose keeps a long-running Claude process via OnceCell (spawned exactly once on first call)
      and sends NDJSON messages via stdin. Default model is claude-sonnet-4-20250514.
      The apply_permission_flags helper (lines 122-147) handles GooseMode mapping.

  - id: ndjson-input-protocol
    description: "Sends user messages as NDJSON objects to Claude stdin"

    reference:
      repository: "https://github.com/block/goose"
      commit: "b18120bec310365d96cafcc34ea63d8534e3ee57"
      path: "crates/goose/src/providers/claude_code.rs"
      lines: [351, 362]
      function: "execute_command"
      class: "ClaudeCodeProvider"
      language: "rust"

    command_pattern: "stdin NDJSON: {\"type\":\"user\",\"message\":{\"role\":\"user\",\"content\":[...]}}"

    snippet: |
      // build_stream_json_input (free function, lines 459-462) constructs the JSON:
      fn build_stream_json_input(content_blocks: &[Value]) -> String {
          let msg = json!({"type":"user","message":{"role":"user","content":content_blocks}});
          serde_json::to_string(&msg).expect("serializing JSON content blocks cannot fail")
      }

      // In execute_command(), lines 351-362: write NDJSON line to stdin
      let ndjson_line = build_stream_json_input(&new_blocks);
      process
          .stdin
          .write_all(ndjson_line.as_bytes())
          .await
          .map_err(|e| {
              ProviderError::RequestFailed(format!("Failed to write to stdin: {}", e))
          })?;
      process.stdin.write_all(b"\n").await.map_err(|e| {
          ProviderError::RequestFailed(format!("Failed to write newline to stdin: {}", e))
      })?;

    notes: |
      Bidirectional NDJSON protocol - each line is a complete JSON object.
      build_stream_json_input() is a free function (lines 459-462) that serializes the message.
      Content blocks are built by messages_to_content_blocks() (lines 73-120), which supports
      text, image (base64), tool_request, and tool_response message types.

  - id: ndjson-response-parsing
    description: "Parses Claude stdout NDJSON for assistant/result/error events"

    reference:
      repository: "https://github.com/block/goose"
      commit: "b18120bec310365d96cafcc34ea63d8534e3ee57"
      path: "crates/goose/src/providers/claude_code.rs"
      lines: [150, 253]
      function: "parse_claude_response"
      class: "ClaudeCodeProvider"
      language: "rust"

    snippet: |
      fn parse_claude_response(
          &self,
          json_lines: &[String],
      ) -> Result<(Message, Usage), ProviderError> {
          let mut all_text_content = Vec::new();
          let mut usage = Usage::default();

          for line in json_lines {
              if let Ok(parsed) = serde_json::from_str::<Value>(line) {
                  match parsed.get("type").and_then(|t| t.as_str()) {
                      Some("assistant") => {
                          if let Some(message) = parsed.get("message") {
                              // Extract text content from this assistant message
                              if let Some(content) = message.get("content").and_then(|c| c.as_array())
                              {
                                  for item in content {
                                      if item.get("type").and_then(|t| t.as_str()) == Some("text") {
                                          if let Some(text) =
                                              item.get("text").and_then(|t| t.as_str())
                                          {
                                              all_text_content.push(text.to_string());
                                          }
                                      }
                                      // Skip tool_use - those are claude CLI's internal tools
                                  }
                              }
                              // Extract usage information from message.usage
                          }
                      }
                      Some("result") => {
                          // Extract additional usage info from result if available
                      }
                      Some("error") => {
                          let error_msg = parsed
                              .get("error")
                              .and_then(|e| e.as_str())
                              .unwrap_or("Unknown error");
                          if error_msg.contains("context") && error_msg.contains("exceeded") {
                              return Err(ProviderError::ContextLengthExceeded(
                                  error_msg.to_string(),
                              ));
                          }
                          return Err(ProviderError::RequestFailed(format!(
                              "Claude CLI error: {}",
                              error_msg
                          )));
                      }
                      Some("system") => {} // Ignore system init events
                      _ => {}              // Ignore other event types
                  }
              }
          }
          // Combine all text content into a single message with "\n\n" separator
          let combined_text = all_text_content.join("\n\n");
          // ...returns (Message, Usage)

    notes: |
      Four event types handled: assistant (content), result (final usage), error, system (ignored).
      Lines are collected first by execute_command() (lines 364-400) which reads stdout until
      a "result" or "error" event, then passed to parse_claude_response for extraction.
      Error handling distinguishes context length exceeded from other errors.

# Summary of all flags used
flags_summary:
  "--input-format":
    used: true
    invocation_ids: ["claude-code-provider-spawn"]
    notes: "Always set to stream-json for NDJSON bidirectional communication"
  "--output-format":
    used: true
    invocation_ids: ["claude-code-provider-spawn"]
    notes: "Always set to stream-json"
  "--verbose":
    used: true
    invocation_ids: ["claude-code-provider-spawn"]
    notes: "Required for stream-json output"
  "--system-prompt":
    used: true
    invocation_ids: ["claude-code-provider-spawn"]
    notes: "Custom system prompt passed as string argument"
  "--model":
    used: true
    invocation_ids: ["claude-code-provider-spawn"]
    notes: "Only passed for 'sonnet' or 'opus' values"
  "--dangerously-skip-permissions":
    used: true
    invocation_ids: ["claude-code-provider-spawn"]
    notes: "Enabled when GOOSE_MODE=auto"
  "--permission-mode":
    used: true
    invocation_ids: ["claude-code-provider-spawn"]
    notes: "Set to acceptEdits when GOOSE_MODE=smart-approve"
  "--session":
    used: false
    invocation_ids: []
    notes: "NOT used - Goose uses persistent process instead of session IDs"
  "-p":
    used: false
    invocation_ids: []
    notes: "NOT used - uses stdin NDJSON instead of -p flag"
  "--max-turns":
    used: false
    invocation_ids: []
    notes: "NOT used"
  "--mcp-config":
    used: false
    invocation_ids: []
    notes: "NOT used"
  "--allowedTools":
    used: false
    invocation_ids: []
    notes: "NOT used"
